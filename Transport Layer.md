### 王道考研

- 传输层的功能

  - 提供进程和进程之间的逻辑通信
  - 复用和分用
    - 复用：应用层所有的进程都可以通过传输层再传输到网络层
    - 分用：收到网络层的数据后由传输层分出进程
  - 传输层对收到的报文进行差错检测
  - 传输层的两种协议

- TCP

  - 不提供广播或多播服务
  - 时延大

- 端口号

  <img src="Transport%20Layer.assets/image-20210122101059754.png" alt="image-20210122101059754" style="zoom:50%;" />

  ![image-20210122101129198](Transport%20Layer.assets/image-20210122101129198.png)

  - 本地意义
  - 16bit

- UDP

  - 在IP数据报服务上增加：复用分用，差错检测

  - 不保证可靠交付

  - 应用层给UDP多长的报文，UDP就照样发送，一次发一个完整报文

  - 没有拥塞控制：不会限制发送方

  - 首部开销小，8字节，TCP是20字节

  - 首部格式

    <img src="Transport%20Layer.assets/image-20210122101547201.png" alt="image-20210122101547201" style="zoom:50%;" />

    - 数据长度可以为0 —— UDP最短可以为8字节
    - **UDP长度指的是整个用户数据报的长度：首部 + 数据**
    - **UDP检验和：检验首部 + 数据是否有错**
    - 伪首部：只是校验过程中添加的，包括部分IP首部

- TCP

  - 每一条TCP是点对点的：不能广播
  - 可靠有序、不丢不重
  - 全双工通信：设置发送缓存和接收缓存
  - 面向**字节流**：把数据看成仅仅是一连串的无结构的字节流

- TCP首部格式

  <img src="Transport%20Layer.assets/image-20210122160843340.png" alt="image-20210122160843340" style="zoom: 67%;" />

  - **首部：希望是四字节的整数倍**
  - **20字节的固定首部**
  - 序号：传送的字节流的第一个**字节**的序号
  - 确认号：期望收到对方下一个报文段的第一个数据**字节**的序号
    - N表示N-1之前的都收到了
  - TCP头长度：**4B为单位**
  - 6个控制位
  - **URG：为1时表示有紧急数据，不用在缓存里排队**
    - 配合紧急指针
    - 紧急指针指出本报文段中紧急数据的字节数
    - 从头开始的“紧急指针”字节数的数据
    - 发送方的时候优先处理 
  - **ACK：在连接建立后所有传送的报文段都必须把ACK置为1**
  - PSH：为1时接收方尽快交付给接收的应用进程
  - **SYN：为1时表明是一个连接请求/连接接受报文**
  - FIN：为1表明此报文段发送方数据已经发完，要求释放连接
  - 窗口：发送本报文段的一方的接收窗口，即现在允许对方发送的数据量
  - 检验和：**检验首部+数据**，需要加上伪首部

#### TCP连接管理

- 连接建立，数据传送，连接释放

- 数据传输是全双工的

- SYN置为1：连接请求 或 连接请求的确认

- <img src="Transport%20Layer.assets/image-20210125192225578.png" alt="image-20210125192225578" style="zoom:67%;" />

- ![image-20210123190204705](Transport%20Layer.assets/image-20210123190204705.png)

- 洪泛攻击

  <img src="Transport%20Layer.assets/image-20210123190319067.png" alt="image-20210123190319067" style="zoom: 67%;" />

- 连接释放

  ![image-20210123190709880](Transport%20Layer.assets/image-20210123190709880.png)

  - 两个进程中的任何一个都能终止该连接，连接结束后释放资源

#### TCP可靠传输

- 网络层：提供尽最大努力交付，不可靠传输
- 可靠：接收方进程从缓存区读出的字节流与发送方发出的字节流是一样
- TCP默认使用累计确认
- 重传：超时重传
  - 不同的报文段传的时间不同 --> 重传时间会波动
  - TCP采用自适应算法，动态改变重传时间RTTs（加权平均往返时间）
- 冗余ACK
  - 发送方收到3个对于某个报文段的冗余ACK，认为其后一个报文段丢失，重传
  - **快速重传**

#### TCP流量控制

- TCP利用滑动窗口机制实现流量控制
- 接收方根据自己**接收缓存的大小**，动态地调整发送方地发送窗口大小
  - 设置确认报文段的**窗口字段**
  - 发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值
- TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的0窗口通知，就启动持续计时器
  - 若到期，则发送方发送一个0窗口探测报文段，接收方收到探测报文段时给出现在的窗口值

#### TCP拥塞控制

- 全局性的问题

- 慢开始 拥塞避免 

- 快重传 快恢复

- 拥塞窗口与接收窗口

  - 拥塞窗口：**发送方**根据自己估算的网络拥塞程度而设置的窗口值
  - 接收窗口：**接收方**根据接收缓存设置的值，并告知给发送方

- 慢开始和拥塞避免

  <img src="Transport%20Layer.assets/image-20210125180454777.png" alt="image-20210125180454777" style="zoom:50%;" />

  - 传输轮次：发送了一批报文段并收到它们的确认的时间
    - 一个RTT

  - 慢开始：起始是1个报文段
  - 收到确认后就翻倍
  - ssthresh：慢开始门阈值
  - 超过ssthresh后开始拥塞避免：每次加1
  - 拥塞后瞬间减为1，ssthresh会变成拥塞时拥塞窗口的一半

- 快重传和快恢复

  ![image-20210125180727086](Transport%20Layer.assets/image-20210125180727086.png)

  



- 传输层针对的是进程
- ![image-20201215101402663](Transport%20Layer.assets/image-20201215101402663.png)
  - 哪个地方填什么要知道
- 数据链路层负责点对点的东西
  - 关心的两个东西：**顺序不变、没有存储能力**
  - 路由器是带有内存的
  - 必须解决这两个问题
- 运输层：端对端
- 将端对端尽可能变成点对点的模式
- NSAP：网络层的服务接入点
  - 针对任务 / 针对结点
- ip地址仅仅到结点，运输层还需要地址，如果是TCP/UDP，则是端口号
  - 标识运输层的端点：ip地址 + 端口号
  - 这个加和叫做 socket
  - **标识运输层的连接**：两个端点的socket
  - 两个端点来标识一个连接有个小漏洞：连接一般都是动态建立，包还在路由的时候连接被释放了，连接释放了但包没有消灭
    - 但如果后来又重新建立了这个连接，这个连接**逻辑上应该不是刚刚的连接**，选了相同的端口号，前面在逛街的包在建立成功的时候活过来了，然后给了接收方。因为端点是对的，会被接收。这样会有问题
    - 空间上有区分，时间上没有区分
    - 主要原因：包可以缓冲
    - 前面连接和后面连接的序号不一样（联想滑动窗口协议）
    - 标识连接的另一点：通过序号来区分前面一个和后面一个连接
      - 最近的合理的没有被用的序号
- **HDLC**
- 总是希望网络是无中心的
- 连接的建立
  - 三次握手（年年都考）
  - 发送连接建立请求 --> 连接建立请求确认 --> 再发一个确认的确认
  - 保证前面两个包没问题，主要防止张冠李戴
- 连接的释放
  - 两军问题
- 差错控制和流量控制
  - 传输层接收方多次收到同一个包：不算错误
  - 流量控制完全由接收方控制
  - 运输层的连接是存在于通讯子网上的
  - 拥塞控制在数据链路层是不涉及的
  - 拥塞控制由发送方做主，自我克制
- 多路复用
  - 运输层：涉及到通信的最后一道关卡
  - 弥补通信子网和网络应用的差距
  - ...
- 崩溃恢复
  - 不知道死掉之前用的是什么序号
- **拥塞控制**
  - 理想的带宽分配
  - 调整发送速率

#### Internet传输协议：UDP

- **User Datagram Protocol**

##### 比较

- TCP是面向连接的，UDP是无连接的
  - TCP可靠性好，UDP可靠性不好
  - TCP实时性不好，UDP实时性不好
    - 三次握手
  - TCP是一对一的，UDP是无所谓的
- UDP是面向数据报的（datagram，即**会保持边界**）
- TCP是面向字节流的（不提供包的边界）

##### UDP

- 无连接，不用讨论时序，包的格式及语义

- UDP包一定是整数个字节

- 头部 + payload

  - 头部：四个字节的整数倍
  - 固定头

- UDP就是个IP，UDP需要加端口号，从而可以针对任务

  - 速度快

  <img src="Transport%20Layer.assets/image-20201215113247417.png" alt="image-20201215113247417" style="zoom:50%;" />

- 校验和：不仅算自己，还算了部分的IP

- 用途

  - RPC机制：远程过程调用

    - NFS：网络文件系统
    - 指针问题
    - 需要有相应的规范
    - 序列化 --> marshal

  - RTP, RTCP：实时传输协议，实时传输控制协议

    - 都是用UDP承载的

    <img src="Transport%20Layer.assets/image-20201215114719095.png" alt="image-20201215114719095" style="zoom:50%;" />

    - 多媒体数据对可靠性不是很在意
    - UDP承载多媒体数据非常合适
    - 为多媒体传输建立一个通用的协议
    - RTP是第几层？
      - 第四层，第4.5层，第五层，都不错
      - 认为是通用的：第四层
      - 为应用提供服务：第五层
    - 多媒体的特征
      - 多个流（立体声，双声道，图像/音频流）
      - 流有顺序
      - 流和流之间需要同步

    <img src="Transport%20Layer.assets/image-20201215115622638.png" alt="image-20201215115622638" style="zoom:50%;" />

    - 所属流的ID

##### TCP

- 面向连接的
- 可靠性好（三次握手），实时性不好
- 面向字节流的传输服务（不是面向包）
- 互联网的网络层：无连接
  - 运输层：直接涉及通信的最高的层次
  - HDLC：滑动窗口协议
- TCP滑动窗口
  - 数据链路层的传输时间是确定的，因此窗口大小比较好确定
  - 窗口大小是动态的自适应的：TCP的传输时间不稳定，接收端通知发送端
- TCP超时时间
  - 也是自适应的
  - 超时值不断在变化
- TCP的成功：上面两个值是动态的
- <img src="Transport%20Layer.assets/image-20201222100204265.png" alt="image-20201222100204265" style="zoom:50%;" />
  - 端口号两个字节
    - 1024以下的端口号是统一分配的
    - 1024以上的，操作系统的安排会有不同
  - **UDP和TCP的端口号是独立的**（可以同时使用，比如100）
    - IP地址、端口号、协议唯一确定一个任务
    - 应用层的同一个协议，比如DNS，支持UDP和TCP，一般会给相同的端口号
- <img src="Transport%20Layer.assets/image-20201222100926730.png" alt="image-20201222100926730" style="zoom:50%;" />
  - The TCP **Segment** Header
  - IP的包必须包含整数个字节，头部必须是整数个字（再看看）
  - TCP的头部：固定头（5个字，20字节） + 可选头（0个或多个字）
  - 校验和：对头部进行校验
    - IPv6：头部没有校验和
  - TCP和UDP没有版本号：运输层本质上是端对端的，两边都升级就好，不涉及到全网
    - IP改协议需要让所有路由器升级，做不到
  - 头长度：字为单位
  - 序号：数字节数
  - 确认号：和HDLC一样，等待到来，这个之前的都收到了
  - 左边两个比特：后来新加的，不太用
  - SYN为1，其他为0，...
  - PSH：接收方看到是PSH为1，就赶紧交给应用层
  - URG：
    - 比如Ctrl+c
    - 不能保证比普通流快
    - Urgent pointer
    - URG置1：**并不表示这个包里有紧急数据**，但是进入了紧急状态，流上一定有紧急数据
- 数据通信阶段
  - HDLC收包是按顺序收的，TCP不是的
  - TCP没有要求重发的机制
  - 采用主动重发机制：超时后主动重发
  - TCP的通信子网中可能存在阻塞的情况
    - 流量控制：由接收方决定，窗口大小字段，通知发送方的发送窗口目前只能有多少
    - 拥塞控制：由发送方自律，不要发得太过分
      - 慢启动等
- **状态机，认真看一遍！！！！！！可能会考！！！！！**
- 滑动窗口
- 慢启动：11：20左右
- 

